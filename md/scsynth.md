# scsynth (November, 2015)

Send control messages to `scsynth` and print replies.

## buffer

`buffer query` sends a `/b_query` message and prints the `/b_info` reply.

~~~~
$ hsc3-scsynth buffer query 0
buffer-id      : 0
frame-count    : 256
channels-count : 1
sample-rate    : 48000.0
$
~~~~

`buffer store` writes the buffer contents to a `NeXT/AU` file.

`buffer store-seq` writes a sequence of time-stamped `NeXT/AU` files to the indicated directory.
Timestamps are either `ISO 8601` format or `NTP` integer format.

~~~~
$ hsc3-scsynth buffer store-seq 12 0.1 iso /tmp
^C
$ for i in /tmp/*.au ; do hsc3-sf-draw table pbm 0 12 128 0 $i $i.pbm ; done
$ convert /tmp/*.pbm -delay 1 -loop 0 ~/sw/hsc3-data/data/gif/monopole.gif
$
~~~~

![](sw/hsc3-data/data/gif/monopole.gif)

## dump-osc

`dump-osc` sets the flag that tells scsynth to print (or not) incoming OSC messages.

## group

`group query-tree` sends a `/g_queryTree` message and prints the `/g_queryTree.reply`.

## message

`message print address` prints messages that arrive _from_ scsynth
(after requesting notification) that have `address`, ie. `/tr` for
the messages sent by `sendTrig`.

## node

`node query` sends an `/n_query` message and prints the `/n_info` reply.

## nrt

`nrt audition` loads and runs an NRT file.

`nrt stat` prints information about an NRT file.

## reset

`reset`, runs `/clearSched` and `/g_freeAll` and `/g_new`, `C-cC-k` in emacs.

## scsyndef dump-ugens (April, 2021)

Print synthdef file using the format generated by SynthDef>>dumpUGens.

## scsyndef print (October, 2020)

Print synthdef file using a plain text format.

## scsyndef read (April, 2021)

Read the text synthdef file format generated by `print` (above) and write a binary synthdef file.

## scsyndef stat (October, 2014)

Read the binary representation of a
[SuperCollider](http://audiosynth.com) graph and print the output of
the [hsc3](?t=hsc3) function `graph_stat`.

~~~~
$ hsc3-scsynth scsyndef stat ~/sw/hsc3-graphs/scsyndef/why-supercollider.sc.scsyndef
number of constants       : 35
number of controls        : 0
control rates             : 
control names             : 
number of unit generators : 69
unit generator rates      : KR×14 AR×55
~~~~

The last two entries list the `UGen`s as a set and as a sequence.
These lines can be very long.
Here they are re-written as paragraphs.

~~~~
unit generator set : *×10 +×1 AllpassN×8 CombL×7 DelayN×1 Dust×10
LFNoise1×7 MulAdd×9 Out×1 Resonz×10 Sum3×1 Sum4×4

unit generator sequence : Dust * Resonz Dust * Resonz Dust * Resonz
Dust * Resonz Sum4 Dust * Resonz Dust * Resonz Dust * Resonz Dust *
Resonz Sum4 Dust * Resonz Dust * Resonz + Sum3 DelayN LFNoise1 MulAdd
CombL LFNoise1 MulAdd CombL LFNoise1 MulAdd CombL LFNoise1 MulAdd
CombL Sum4 LFNoise1 MulAdd CombL LFNoise1 MulAdd CombL LFNoise1 MulAdd
CombL Sum4 AllpassN AllpassN AllpassN AllpassN MulAdd AllpassN
AllpassN AllpassN AllpassN MulAdd Out
~~~~

## scsyndef to-hs (July, 2012)

A _disassembler_ for UGen graphs, it reads the binary representation
of a [SuperCollider](http://audiosynth.com) _instrument_ and prints a
_plain_ [hsc3](?t=hsc3) (haskell) notation of the unit-generator
graph.

The _notated_ haskell form of the [why
supercollider?](?t=hsc3-graphs&e=gr/why-supercollider.scd) graph is:

~~~~
why_supercollider :: UGen
why_supercollider =
    let r = resonz (dust 'α' AR 0.2 * 50) (rand 'β' 200 3200) 0.003
        s = mix (uclone 'γ' 10 r)
        z = delayN s 0.048 0.048
        c = combL z 0.1 (lfNoise1 'δ' KR (rand 'ε' 0 0.1) * 0.04 + 0.05) 15
        y = mix (uclone 'ζ' 7 c)
        f i = allpassN i 0.05 (randN 2 'η' 0 0.05) 1
        x = useq 'θ' 4 f y
    in out 0 (s + 0.2 * x)
~~~~

The transcript below prints the _reconstruction_ of the binary
encoding of this graph in _plain_ notation.
It is long and here parts are elided.

~~~~
$ hsc3-scsynth scsyndef to-hs ~/sw/hsc3-graphs/scsyndef/why-supercollider.sc.scsyndef
import Sound.SC3
import Sound.SC3.Common.Base
import Sound.SC3.UGen.Plain
why-supercollider.sc :: UGen
why-supercollider.sc =
  let c_0 = constant (0.20::Sample)
      c_1 = constant (50.0::Sample)
      ...
      u_35 = nondet "Dust" (UId 35) AR [c_0] 1
      u_36 = binop CS "*" AR u_35 c_1
      u_37 = nondet "Resonz" (UId 37) AR [u_36,c_2,c_3] 1
      ...
      u_68 = nondet "Sum3" (UId 68) AR [u_67,u_60,u_47] 1
      u_69 = nondet "DelayN" (UId 69) AR [u_68,c_13,c_0] 1
      u_70 = nondet "LFNoise1" (UId 70) KR [c_14] 1
      u_71 = nondet "MulAdd" (UId 71) KR [u_70,c_15,c_16] 1
      u_72 = nondet "CombL" (UId 72) AR [u_69,c_17,u_71,c_18] 1
      ...
      u_98 = nondet "AllpassN" (UId 98) AR [u_92,c_16,c_27,c_26] 1
      u_99 = nondet "AllpassN" (UId 99) AR [u_98,c_16,c_29,c_26] 1
      u_100 = nondet "AllpassN" (UId 100) AR [u_99,c_16,c_31,c_26] 1
      u_101 = nondet "AllpassN" (UId 101) AR [u_100,c_16,c_33,c_26] 1
      u_102 = nondet "MulAdd" (UId 102) AR [u_101,c_0,u_68] 1
      u_103 = nondet "Out" (UId 103) AR [c_34,u_97,u_102] 0
  in u_103
$
~~~~

## status

`status print` sends a `/status` message and prints the `/status.reply`,
`C-cC-p` in emacs.

~~~~
$ hsc3-scsynth status print
***** SuperCollider Server Status *****
# UGens                     219:Int32
# Synths                    5:Int32
# Groups                    3:Int32
# Instruments               22:Int32
% CPU (Average)             6.52046:Float
% CPU (Peak)                6.52434:Float
Sample Rate (Nominal)       48000.0:Double
Sample Rate (Actual)        47998.52114:Double
$
~~~~

`status monitor DELAY` updates a concise status line every `DELAY` seconds.

~~~~
$ hsc3-scsynth status monitor 0.5
UGN=364   GRP=13    SYN=18    INS=10    CPU=4.8   SR=47998.7
$
~~~~

## wait-for

Wait until `scsynth` is responsive (ie. replies to a `c_get` message).
